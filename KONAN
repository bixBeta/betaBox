
R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-redhat-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> #!/bin/env RScript
> # written by Faraz Ahmed 
> # initial commit 11/15/2018
> ## -------------------------------------------------------------------------------------------------------------------
> ## -------------------------------------------------------------------------------------------------------------------
> ## -------------------------------------------------------------------------------------------------------------------
> 
> 		# USAGE SYNTAX:
> 		# $ RScript DESeq2.R <Experiment.Name> <Numerator> <Denominator>  
> 
> ## -------------------------------------------------------------------------------------------------------------------
> ## -------------------------------------------------------------------------------------------------------------------
> ## -------------------------------------------------------------------------------------------------------------------
> 
> 
> suppressWarnings(library("dplyr"))

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> suppressWarnings(library("DESeq2"))
Loading required package: S4Vectors
Loading required package: stats4
Loading required package: BiocGenerics
Loading required package: parallel

Attaching package: ‘BiocGenerics’

The following objects are masked from ‘package:parallel’:

    clusterApply, clusterApplyLB, clusterCall, clusterEvalQ,
    clusterExport, clusterMap, parApply, parCapply, parLapply,
    parLapplyLB, parRapply, parSapply, parSapplyLB

The following objects are masked from ‘package:dplyr’:

    combine, intersect, setdiff, union

The following objects are masked from ‘package:stats’:

    IQR, mad, sd, var, xtabs

The following objects are masked from ‘package:base’:

    anyDuplicated, append, as.data.frame, basename, cbind, colMeans,
    colnames, colSums, dirname, do.call, duplicated, eval, evalq,
    Filter, Find, get, grep, grepl, intersect, is.unsorted, lapply,
    lengths, Map, mapply, match, mget, order, paste, pmax, pmax.int,
    pmin, pmin.int, Position, rank, rbind, Reduce, rowMeans, rownames,
    rowSums, sapply, setdiff, sort, table, tapply, union, unique,
    unsplit, which, which.max, which.min


Attaching package: ‘S4Vectors’

The following objects are masked from ‘package:dplyr’:

    first, rename

The following object is masked from ‘package:base’:

    expand.grid

Loading required package: IRanges

Attaching package: ‘IRanges’

The following objects are masked from ‘package:dplyr’:

    collapse, desc, slice

Loading required package: GenomicRanges
Loading required package: GenomeInfoDb
Loading required package: SummarizedExperiment
Loading required package: Biobase
Welcome to Bioconductor

    Vignettes contain introductory material; view with
    'browseVignettes()'. To cite Bioconductor, see
    'citation("Biobase")', and for packages 'citation("pkgname")'.


Attaching package: ‘Biobase’

The following object is masked from ‘package:BiocGenerics’:

    dims

Loading required package: DelayedArray
Loading required package: matrixStats

Attaching package: ‘matrixStats’

The following objects are masked from ‘package:Biobase’:

    anyMissing, rowMedians

The following object is masked from ‘package:dplyr’:

    count

Loading required package: BiocParallel

Attaching package: ‘DelayedArray’

The following objects are masked from ‘package:matrixStats’:

    colMaxs, colMins, colRanges, rowMaxs, rowMins, rowRanges

The following objects are masked from ‘package:base’:

    aperm, apply

> ## -------------------------------------------------------------------------------------------------------------------
> args <-  commandArgs(trailingOnly = T)
> outputPrefix <- args[1] # Experiment Name e.g. Morgan.Sammons.0002
> numerator   <- args[2]
> denominator <- args[3]
> 
> 
> ## -------------------------------------------------------------------------------------------------------------------
> 
> phenoData <- read.csv(file = "phenoData.csv", header = T)
> countMatrix <- read.table(file = "countMatrix.txt", header = F)
> 
> 
> ## -------------------------------------------------------------------------------------------------------------------
> 
> # --- storing meta info -------------------------
> 
> sampleNames <- phenoData$sampleName
> condition <- phenoData$condition
> myDim <- ncol(countMatrix)/2
> rawCounts <- countMatrix
> 
> n <- (0:myDim)*2
> n[1] <- 1
> 
> countTable <- rawCounts[,n]
> rownames(countTable) <- countTable[,1]
> countTable <- select(countTable, -V1)
> colnames(countTable) <- phenoData$sampleName
> 
> # --- final check ------------------------------
> phenoData$sampleName == colnames(countTable)
[1] TRUE TRUE TRUE TRUE TRUE TRUE
> 
> 
> 
> # FOR HTSEQ  -- CHECK 
> #grep("__",x = row.names(countTable))
> #countTable[grep("__",x = row.names(countTable)),] # rm if TRUE
> 
> #countTable <- countTable[1:26364,] # check rows total
> #countTable[grep("__",x = row.names(countTable)),] # verify
> 
> print(" ", quote = F)
[1]  
> print(" ", quote = F)
[1]  
> print("                           RUNNING DESEQ2                              ", quote = F)
[1]                            RUNNING DESEQ2                              
> print(" ", quote = F)
[1]  
> print(" ", quote = F)
[1]  
> 
> ## -------------------------------------------------------------------------------------------------------------------
> dds <- DESeqDataSetFromMatrix(countData = countTable,
+                               colData = phenoData,
+                               design = ~ condition)
> 
> treatments = unique(phenoData$condition) # Treatments of interest
> dds$condition <- factor(colData(dds)$condition,
+                         levels = treatments)
> 
> ## -------------------------------------------------------------------------------------------------------------------
> dds <- DESeq(dds)
estimating size factors
estimating dispersions
gene-wise dispersion estimates
mean-dispersion relationship
final dispersion estimates
fitting model and testing
> resultsNames(dds)
[1] "Intercept"             "condition_ZKV_vs_Mock"
> 
> ## -------------------------------------------------------------------------------------------------------------------
> # transform raw counts into normalized values
> # DESeq2 has two options:  1) rlog transformed and 2) variance stabilization
> # variance stabilization is very good for heatmaps, etc.
> rld <- rlogTransformation(dds, blind=T)
> vsd <- varianceStabilizingTransformation(dds, blind=T)
> 
> # save normalized values
> write.table(as.data.frame(assay(rld)),file = paste0(outputPrefix, ".rlog-transformed-counts.txt"), sep = '\t')
> write.table(as.data.frame(assay(vsd)),file = paste0(outputPrefix, ".vst-transformed-counts.txt"), sep = '\t')
> 
> ## -------------------------------------------------------------------------------------------------------------------
> ## use contrast to drop deseq2 results for specific conditions; following are some expamples
> 
> # WD.WN <- results(dds, contrast=c("condition","WD","WN"), alpha = 0.05)
> # pd.pn <- results(dds, contrast=c("condition","PD","PN"), alpha = 0.05)
> # Ad.An <- results(dds, contrast=c("condition","AD","ANU"), alpha = 0.05)
> # write.csv(WD.WN, file = paste0(outputPrefix, ".WD.WN.results.csv"))
> # write.csv(pd.pn, file = paste0(outputPrefix, ".pd.pn.results.csv"))
> # write.csv(Ad.An, file = paste0(outputPrefix, ".Ad.An.results.csv"))
> # write.csv(WD.pd, file = paste0(outputPrefix, ".WD.pd.results.csv"))
> 
> save(countTable, phenoData, dds, rawCounts, rld, vsd, file = paste0(outputPrefix, ".Rdata"))
> 
> custom <- results(dds, contrast=c("condition", numerator, denominator), alpha = 0.05)
Error in if (contrast[2] == contrast[3]) { : 
  missing value where TRUE/FALSE needed
Calls: results -> checkContrast
Execution halted
